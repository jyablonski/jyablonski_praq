# Rust
[Guide](https://datawithrust.com/)
[Blog Post](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)

Rust is a systems programming language that acts as a memory safe and performant competitor to C++.  It was started in 2006 and 1.0 was released in 2015.  It's still a new language by programming standards and is gaining more and more traction over time.

How it works is you write code that is compiled into machine code and then executed, using the Rust Compiler + LLVM.  The code generated by this process is platform or OS independent.  The Rust Compiler converts the code we type into machine code (LLVM) before it actually runs.

Compiled languages do have some downsides, including:
- Build Times.  Compilation is an additional step in the process of developing software applications.
- Verbosity.  Statically typed languages increases the time it takes for developer to write code.
- Flexibility.  Changing anything requires a re-compilation and relinking before being able to run the code again.

Rust is statically typed, so you must type all of your variables as you code so that they're known at compile time.  Python is a dynamically language which doesn't enforce type safety.  The Python Interpreter checks every line one-by-one as it runs to figure out what the types are before executed it in the Python Virtual Machine.  This can lead to type issues at runtime.
- `python_random_fail.py`
- `rust_random_fail.rs`
- The Python file will sometimes run and sometimes fail, the Rust file fails at compilation and immediately spits out an error before a programmer can ever run the code.

Ownership means that any given value has one owner for its lifetime.  The owner is responsible for allocating and deallocating memory occupied by that value for its lifetime.  This is helpful to know for memory leaks.

Borrowing makes it posible to pass around references for values without changing or transferring its ownership.  Think of this like an alias to the contents of a value.  Different parts of the program can use these values without requiring a copy step.  
- Borrowing can be done in a mutable (changing the value) or immutable (not changing the value) way
- Only one mutable borrow of a value can be active at a time.
- Ownership is temporarily given up during borrowing.
- Like if you gave your friend your console and then that friend lets other people play on the console while he has it.

These concepts help prevent data races by enforcing strict rules over shared resources.  This is important when dealing with concurrent programs.  Rust has built in support for safe concurrencyt without the mess which is good for data-intensive tasks.

Rust is a bit more verbose than Python, because it is statically typed and has the borrowing stuff and all the `{}` `;` syntax.  Adding Types helps the compiler prepare and implement optimizations for you.

``` py
def main(arr):
    concatenated = "".join(arr)
    print(concatenated)

main(["Hello", "world", "!"]) # works
main("Hello there") # works too

```

``` rs
fn main() {
    let arr = ["Hello", "world", "!"];
    let concatenated = &arr.join("");
    println!("{:?}", concatenated);
}
```

### What else Besides Rust or Python
So why not Java then?  Tons of Applications and Libraries are written in it like Spark, Debezium, Flink, and many more.  Java is just as verbose and a bit more difficult to read, write, and maintain.  Scala does a slightly better job at this and is a concise alternative to Java that still runs on the JVM, but with a steep learning curve.

Go has faster compile times and built in concurrency support, and relatively easy to learn.  It's a great language for things like microservices with a lot of network traffic.

C++ has one of the steepest learning curves and requires manual data management and a ton of expertise using & manipulating the language.  It's about as low level of a programming language as you can get.

Rust may not be as bleeding-edge performant as C++, but it is a bit more easy to use and a tad more flexbile while being more maintainable over time.  Use Python when you can, but when you run into problems that require high performance then Rust can be a good option.

### Building Rust Code
``` rs
// this manually compiles the rust program
rustc hello_world.rs

// the above command generates this binary executable file
./hello_world

// format code like for black
rustup component add rustfmt
cargo fmt
rustfmt hello_world.rs

// update the langauge 
rustup update

rustc --version
cargo --version
```

### Tooling
Python needs multiple Tools such as MyPy, Pip, venv, and pytest to help enable you to do all sorts of different things to get a solid software development environment going.

With Rust, you'll use Cargo which is Rust's Package Manager and Build Tool.  It comes bundled with Rust by default.  It has the ability to automatically build and link native libraries which is a complex task in other programming languages.  The one downside is you can sometimes get long compile times.

### Cargo
Cargo is a Tool that automates compiling code, managing dependencies, and generating documentation.  It simplifies the process of building and sharing Rust Programs.  It can also run Tests.

``` sh
# creates a new direcetory with a `Cargo.toml` file and a `src/` directory.
cargo new data-with-rust

# cargo is using rustc behind the scenes.
cargo build

./target/debug/data-with-rust

```
